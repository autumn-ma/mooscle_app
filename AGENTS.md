This AGENTS.md file serves as a comprehensive guide for working with the Mooscle project. It outlines core technologies, common workflows, and specific instructions to optimize your agentic coding experience, ensuring a smooth development process.
Project Overview

Mooscle is a minimal, self-hosted productivity and fitness companion designed to help users track workouts and body weight, visualize progress, and stay motivated through "adaptive task quantities" that gently "punish" skipped reps. It's cross-platform, installable as a PWA, and boasts an offline-first architecture with data stored securely on-device using SQLite.
Core Files and Utility Functions

    ./lib/main.dart: This is the primary entry point for the Flutter application, where the main runApp function is called and the root widget of the application is defined.
    ./pubspec.yaml: This file defines the project's dependencies (e.g., fl_chart), metadata, assets, and other configurations. It's crucial for managing external packages and project settings.
    ./pubspec.lock: Generated by flutter pub get, this file locks down the exact versions of dependencies used in the project, ensuring consistent builds across different environments.
    ./android/, ./ios/, ./web/, ./linux/, ./windows/, ./macos/: These directories contain the platform-specific code and configurations for each supported environment (Android, iOS, Web, Linux, Windows, macOS). When running flutter run, the appropriate platform-specific build process is initiated here.
    Local SQLite Store: Mooscle's core data persistence relies on a local SQLite database. This means all user data is stored securely on their device, enabling offline-first functionality and eliminating the need for accounts or internet connectivity.
    Adaptive Task Quantity (new_quantity = ceil(old_quantity * (1 + penalty_rate))): This formula, central to Mooscle's "punishment" system, is applied when a workout task is marked as skipped. The penalty_rate defaults to 0.2 (20%), and users can customize it globally or per-task.
    fl_chart: This is the primary library used for all data visualizations (Workout Volume, Best Sets, Weight Trend). Expect to interact with fl_chart implementations when dealing with charting components.

Common Bash Commands

    git clone https://github.com/your-handle/simplefit-todo.git: Clone the Mooscle repository. Remember to replace your-handle with the actual repository owner.
    cd simplefit-todo: Navigate into the cloned project directory.
    flutter pub get: Install all project dependencies. This command must be run after cloning or pulling changes to pubspec.yaml.
    flutter run -d chrome: Start the Mooscle web application in Chrome.
    flutter run -d android: Run the app on an Android emulator or connected device.
    flutter run -d ios: Run the app on an iOS simulator or connected device.
    git status: Check the current state of your Git repository (modified files, staged files, etc.).
    git add .: Stage all changes in your working directory for the next commit.
    git commit -m "feat: add descriptive message": Commit your staged changes. Always follow Conventional Commits for your messages.
    git push origin <your-branch-name>: Push your committed changes to the remote repository. Replace <your-branch-name> with the name of your feature branch.
    flutter test: Run the project's test suite. Ensure all tests pass before committing or opening a PR.

Code Style Guidelines

    Flutter/Dart Conventions: Adhere to the official Dart Style Guide and Flutter's best practices.
    Conventional Commits: All commit messages must follow the Conventional Commits specification. This is critical for clear project history and automated tooling.
    Clarity and Readability: Prioritize writing clear, concise, and human-readable code. Use meaningful variable, function, and class names.
    Widget Structure: Follow standard Flutter widget best practices (e.g., separating concerns into smaller, reusable widgets).

Workflow Guidelines for Agentic Development

When approaching tasks, always consider the following to optimize your coding experience:
General Approach

    Explore and Plan: Before writing any code, thoroughly review the relevant files and the project structure. For instance, if you're working on a new workout tracking feature, you might want to look at lib/main.dart for the overall app structure and consider how new data will integrate with the SQLite store. Always make a clear plan for how to tackle the problem.
    Ultra-Thinking: For any complex problem, or when you need to deeply analyze alternatives (e.g., choosing the best way to implement a new chart type or integrate a new health API), YOU MUST engage ultrathink. This dedicates maximum computation time for a more profound, nuanced analysis and decision-making.
    Implement Incrementally: Break down larger tasks into the smallest possible, manageable steps. This allows for easier debugging and verification at each stage.
    Verify and Iterate: After making changes, always verify their correctness. If something isn't quite right, use Escape (to interrupt), double-tap Escape (to edit previous prompts), or /clear (to reset the context for a fresh start) to adjust your approach.
    Commit Often: Once a logical piece of work is complete and verified, commit it with a clear Conventional Commit message.

Specific Instructions

    Be Specific: Provide precise instructions. Instead of "fix the charts," say "Refactor the fl_chart implementation in the workout visualization section to improve performance on large datasets, specifically optimizing the LineChart and BarChart builders."
    File References: Explicitly mention files or directories when you want me to inspect or modify them. For example: "Examine lib/main.dart to understand the app's initial routing setup."
    Visual Requirements: If a task involves UI changes or new features, provide screenshots, mockups, or detailed descriptions of the desired visual outcome.
    Data Input: You can paste data directly, pipe it into the agent (cat data.txt | AGENTS), or instruct me to read specific files (e.g., "Read the contents of pubspec.yaml to list all dependencies.").
    GitHub Interactions: I can use the gh CLI. Feel free to ask me to create PRs, fix failing CI/CD builds, or triage issues based on the project's contribution guidelines.

Common Workflows

    Adding a New Feature (e.g., BLE Auto-logging):
        ultrathink: Analyze the requirements, research necessary Flutter packages (e.g., for BLE communication), and understand how this new data will integrate with the existing SQLite structure and UI.
        Formulate a detailed, step-by-step implementation plan.
        Implement the feature incrementally, creating new services, data models, and UI components as needed.
        Write and run unit and widget tests to verify functionality.
        Commit changes following Conventional Commits and create a pull request.
    Debugging a Bug (e.g., Chart Data Display Issue):
        ultrathink: Examine error messages, review relevant fl_chart implementation files, and investigate the data being fed into the charts (consider the SQLite data retrieval logic).
        Propose a diagnostic plan (e.g., add logging, isolate the issue in a minimal reproducible example).
        Implement fixes and verify correctness through testing or direct observation within the app.
        Commit the fix with a fix: type message.
    Refactoring (e.g., main.dart structure):
        ultrathink: Understand the current code, identify areas for improvement (e.g., breaking main.dart into smaller, more focused files), and clearly define the refactoring goal (e.g., improving modularity, enhancing testability).
        Create a step-by-step refactoring plan to minimize disruption to existing functionality.
        Execute the refactoring, ensuring that existing functionality is preserved (this is where good tests are invaluable!).
        Commit the refactored code with a refactor: type message.

Allowed Tools

By default, I will ask for explicit permission before modifying your system. For a smoother and more efficient workflow, consider allowing the following tools:

    Edit: Grants permission for me to directly modify project files.
    Bash(git commit:*): Allows me to perform Git commit operations.

Remember to experiment and find the tool permissions and workflow patterns that work best for your development style! I'm here to help you code more efficiently and effectively.
